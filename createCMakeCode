#!/usr/bin/env python
"""Parses the output generated by wmake in OBJECTS_DIR and produces CMake files
from it. For safety reasons it also writes them to OBJECTS_DIR.

"""

import datetime
import os
import os.path as op
import re
import sys

if len(sys.argv) < 3:
  raise AssertionError(
    'Error: requries a target kind and a path pointing to Make/wmakeToCMake')

targetType = sys.argv[1]
if re.match('^(app|lib|test|tutorial)$', targetType) is None:
  raise AssertionError(
    'Error: only target types allowed are "lib", "app", "test" and "tutorial"')

isLib = targetType == 'lib'
isApp = targetType == 'app'
isTest = targetType == 'test'
isTutorial = targetType == 'tutorial'

wmakeDir = sys.argv[2]
if not op.isdir(wmakeDir):
  raise AssertionError(
      'Error: the path "%s" does not exist or is not a directory'%wmakeDir)

targetNameTxt = op.join(wmakeDir,'targetName.txt')
targetTypeTxt = op.join(wmakeDir,'targetType.txt')
sourceFilesTxt = op.join(wmakeDir,'sourceFiles.txt')
includeDirsTxt = op.join(wmakeDir,'includeDirs.txt')
definesTxt = op.join(wmakeDir,'defines.txt')
compileFlagsTxt = op.join(wmakeDir,'compileFlags.txt')
linkLibrariesTxt = op.join(wmakeDir,'linkLibraries.txt')
linkFlagsTxt = op.join(wmakeDir,'linkFlags.txt')

# check required files exist
for f in (targetNameTxt, targetTypeTxt, sourceFilesTxt, includeDirsTxt,
          definesTxt, compileFlagsTxt, linkLibrariesTxt, linkFlagsTxt):
  if not op.isfile(f):
    raise AssertionError(
      'Error: the path "%s" does not exist or is not a file. '+
      'Run modified wmake first.'%f)

baseDir = op.dirname(op.dirname(op.realpath(wmakeDir)))

d1 = op.basename(op.dirname(baseDir))
d2 = op.basename(op.dirname(op.dirname(baseDir)))
if d2 == 'src' and d1 == 'Pstream':
  sys.stderr.write('\nERROR: Cannot handle Pstream, do it yourself!\n\n')
  sys.exit(2)

header = \
r"""#-------------------------------------------------------------------------------
#               ______                _     ____          __  __
#              |  ____|             _| |_  / __ \   /\   |  \/  |
#              | |__ _ __ ___  ___ /     \| |  | | /  \  | \  / |
#              |  __| '__/ _ \/ _ ( (| |) ) |  | |/ /\ \ | |\/| |
#              | |  | | |  __/  __/\_   _/| |__| / ____ \| |  | |
#              |_|  |_|  \___|\___|  |_|   \____/_/    \_\_|  |_|
#
#                   FreeFOAM: The Cross-Platform CFD Toolkit
#
# Copyright (C) 2008-%(currentYear)d Michael Wild <themiwi@users.sf.net>
#                         Gerber van der Graaf <gerber_graaf@users.sf.net>
#-------------------------------------------------------------------------------
# License
#   This file is part of FreeFOAM.
#
#   FreeFOAM is free software; you can redistribute it and/or modify it
#   under the terms of the GNU General Public License as published by the
#   Free Software Foundation; either version 2 of the License, or (at your
#   option) any later version.
#
#   FreeFOAM is distributed in the hope that it will be useful, but WITHOUT
#   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
#   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
#   for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with FreeFOAM; if not, write to the Free Software Foundation,
#   Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
#-------------------------------------------------------------------------------

"""

footer = r"""
# ------------------------- vim: set sw=2 sts=2 et: --------------- end-of-file
"""

#
# deal with Make/files stuff
#
sourceFiles = map(lambda f: f.strip(), open(sourceFilesTxt).readlines())
sourceFiles = filter(len, sourceFiles )
mainSource = sourceFiles[-1]

# allways search for sources, because we need allSources for demangling
regex = re.compile('\.[CHLch]')
allSources = []
for root, dirs, files in os.walk(baseDir,followlinks=True):
  for d in ('Make','lnInclude'):
    if d in dirs:
      dirs.remove(d)
  root = op.relpath(root,baseDir)
  # chatch the case where root is now ./
  if root == '.':
    root = ''
  files = map(lambda f: op.join(root,f),
      filter(lambda f: regex.match(op.splitext(f)[1]), files ))
  allSources.extend(files)

# demangle sourceFiles
for idx, f in enumerate(sourceFiles):
  if not op.isfile(op.join(baseDir,f)):
    # fix .Cver -> .C.in
    if op.splitext(f)[1] == '.Cver':
      sourceFiles[idx] = f.replace('.Cver','.C.in')
      continue
    # construc regex
    r = '[^/]*' + \
      re.escape(f).replace(r'\.', r'[^/]*\.').replace(r'\/',r'[^/]*\/[^/]*')
    # if the file ends on .C, also look for .L
    n, e = op.splitext(r)
    if e == '.C':
      e = '.[CL]'
    r = n + e
    regex = re.compile(r)
    # find possible matches
    df = filter( lambda f: regex.match(f) is not None, allSources )
    if not df:
      sys.stderr.write('DEBUG: Failed to find match with r = "%s" in %s\n'%(r,' '.join(allSources)))
      raise AssertionError(
          'Failed to demangle %s in %s (no candidates found)'%
          (f,baseDir))
    elif len(df) > 1:
      raise AssertionError(
          'Failed to demangle %s in %s (multiple candidates found: %s)'%
          (f,baseDir,' '.join(df)))
    else:
      sourceFiles[idx] = df[0]

headerFiles = []
if isLib:
  noHeaders = sourceFiles + [
      op.join('.','files.cmake'), op.join('.','CMakeLists.txt')]
  headerFiles = list(set(allSources).difference(noHeaders))
  headerFiles.sort()

#
# deal with Make/options stuff
#
targetName = open(targetNameTxt,'rt').readlines()[0].strip()
targetType = open(targetTypeTxt,'rt').readlines()[0].strip()
includeDirs = filter(len,
    map(lambda d: d.strip(), open(includeDirsTxt,'rt').readlines()))
defines = filter(len,
    map(lambda d: d.strip(), open(definesTxt,'rt').readlines()))
compileFlags = filter(len,
    map(lambda d: d.strip(), open(compileFlagsTxt,'rt').readlines()))
linkLibraries = filter(len,
    map(lambda d: d.strip(), open(linkLibrariesTxt,'rt').readlines()))
if not targetType == 'SEXE' and not 'OpenFOAM' in linkLibraries and \
    not re.match('(OpenFOAM|.*Pstream)',targetName):
  linkLibraries.insert(0,'OpenFOAM')
if isTutorial:
  linkLibraries = map( lambda f: 'FF_'+f, linkLibraries )
linkFlags = filter(len,
    map(lambda d: d.strip(), open(linkFlagsTxt,'rt').readlines()))

sourceVars = ""
if isTutorial:
  sourceVars += " ${SRCS}"
  if isLib:
    sourceVars += " ${HDRS}"

#
# dictionary for string replacements
#
formatDict = {
    'currentYear' : datetime.date.today().year,
    'sourceFiles' : '\n  '.join(sourceFiles),
    'headerFiles' : '\n  '.join(headerFiles),
    'targetName' : targetName,
    'defines' : '" "'.join(defines),
    'includeDirs' : '\n  '.join(includeDirs),
    'compileFlags' : ' '.join(compileFlags),
    'linkLibraries' : '\n  '.join(linkLibraries),
    'linkFlags' : ' '.join(linkFlags),
    'mainSource': mainSource,
    'sourceVars': sourceVars,
}

#
# write files.cmake
#
filesCmakeBody = []
if not isTutorial:
  filesCmakeBody.append(header)
filesCmakeBody.append("""set(SRCS
  %(sourceFiles)s
  )
""")

if isLib:
  filesCmakeBody.append("""
set(HDRS
  %(headerFiles)s
  )
""")

if not isTutorial:
  filesCmakeBody.append(footer)
  filesCmakeBody = ''.join(filesCmakeBody) % formatDict

  filesCmake = open(op.join(wmakeDir,'files.cmake'),'wt')
  filesCmake.write(filesCmakeBody)
  filesCmake.close()

#
# write CMakeLists.txt
#
CMakeListsName = op.join(wmakeDir,'CMakeLists.txt')

CMakeListsBody = [header]
if isTutorial:
  CMakeListsName += '.in'
  CMakeListsBody.append("""project(%(targetName)s)

cmake_minimum_required(VERSION 2.8)

set(FreeFOAM_DIR "@FF_CMAKECONFIG_DIR@")

find_package(FreeFOAM REQUIRED)

include(${FreeFOAM_USE_FILE})

""")
  CMakeListsBody.extend(filesCmakeBody)

if defines:
  sys.stderr.write('\nWARNING(%s): Check add_definitions\n\n'%CMakeListsName)
  CMakeListsBody.append("""
message("WARNING: Check add_definitions in ${CMAKE_CURRENT_LIST_FILE}")
add_definitions("%(defines)s")
""")

if includeDirs:
  sys.stderr.write(
      '\nWARNING(%s): Check include_directories\n\n'%CMakeListsName)
  CMakeListsBody.append("""
message("WARNING: Check include_directories in ${CMAKE_CURRENT_LIST_FILE}")
include_directories(
  %(includeDirs)s
  )
""")

srcsString = ""
if isLib:
  CMakeListsBody.append("""
foam_add_library(%(targetName)s%(sourceVars)s)
""")
else:
  CMakeListsBody.append('\nfoam_add_executable(%(targetName)s%(sourceVars)s)\n')

if compileFlags or linkFlags:
  CMakeListsBody.append("""
message(
  "WARNING: Check COMPILE_FLAGS or LINKER_FLAGS in ${CMAKE_CURRENT_LIST_FILE}"
  )
set_target_properties(%(targetName)s PROPERTIES
""")
  if compileFlags:
    sys.stderr.write('\nWARNING(%s): Check COMPILE_FLAGS\n\n'%CMakeListsName)
    CMakeListsBody.append('  COMPILE_FLAGS "%(compileFlags)s"\n')
  if linkFlags:
    sys.stderr.write('\nWARNING(%s): Check LINKER_FLAGS\n\n'%CMakeListsName)
    CMakeListsBody.append('  LINKER_FLAGS "%(linkFlags)s"\n')
  CMakeListsBody.append('  )\n')

if linkLibraries:
  CMakeListsBody.append("""
foam_target_link_libraries(%(targetName)s
  %(linkLibraries)s
  )
""")

if not isTutorial:
  CMakeListsBody.append("""
foam_install_targets(%(targetName)s)
""")

CMakeListsBody.append(footer)
CMakeListsBody = ''.join(CMakeListsBody) % formatDict

CMakeListsTxt = open(CMakeListsName,'wt')
CMakeListsTxt.write(CMakeListsBody)
CMakeListsTxt.close()

